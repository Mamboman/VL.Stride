
shader TestTessellationBezier3d : Transformation, ShaderUtils
{
    float tessFactorMult = 1;

    stream float4 PosW : CPOINT;
    stream float4 PosWVP : SV_Position;

    // Default InstanceId for VS/GS shaders
    stream uint VertexID : SV_VertexID;

    // Default COLOR outputs for PS shader
    stream float4 ColorTarget : SV_Target0;

    StructuredBuffer<float3> CtrlPointsPosBuffer;


    // VS ==============================================================================

    stage void VSMain() 
    {
        float3 p = CtrlPointsPosBuffer[streams.VertexID];
        streams.PosW = float4(p, 1);
    }


    //// HS CONSTANT ===================================================================

    patchstream float tessFactor[2] : SV_TessFactor;

    void HSConstantMain(InputPatch<Input, 3> input, const OutputPatch<Input2, 3> output, out Constants constants) 
    {
        constants.tessFactor[0] = 1.0f;
        constants.tessFactor[1] = tessFactorMult;
    }


    //// HS ==============================================================================

    [domain("isoline")]
    [partitioning("fractional_even")]
    [outputtopology("line")]
    [outputcontrolpoints(3)]
    [patchconstantfunc("HSConstantMain")]
    void HSMain(InputPatch<Input, 3> input, out Output output, uint uCPID : SV_OutputControlPointID) 
    {
        streams = input[uCPID];
        streams.PosW = streams.PosW;
        output = streams;
    }

    //// DS ==============================================================================

    
    [domain("isoline")]
    void DSMain(const OutputPatch<Input, 3> input, out Output output, in Constants constants, float2 uv : SV_DomainLocation) 
    {    

	    /*Here we only need the x component (from 0 to 1) 
	    of the DomainLocation (which we can use to compute bezier)*/
        float t = uv.x;
	
	    //Compute bezier from quadratic formula
	    float3 pos = pow(1.0f - t, 2.0f) * input[0].PosW.xyz 
	    + 2.0f * (1.0f - t) * t * input[1].PosW.xyz
	    + (t*t) * input[2].PosW.xyz ;

	    //Project in screen space (if we have a camera
        streams.PosWVP = mul(float4(pos, 1.0f), ViewProjection);

        output = streams;
    }

    // PS ==============================================================================

    void PSMain()
    {
        streams.ColorTarget = float4(1,1,1,1);
    }
};


