
shader InstanceNoodlesSplines : PositionStream4Base, ShaderBaseStream, Transformation, ShaderUtils, HappyBicubicUtils, HappyStructuredBufferUtils
{
    StructuredBuffer<float3> ControlPointBuffer;
    StructuredBuffer<float> RadiusBuffer;
    //StructuredBuffer<float4x4> TexTransformBuffer;
    //StructuredBuffer<float4x4> TransformBuffer;

    struct SplineSettings
    {
        int VertexPerSpline;
        int ControlPointPerSpline;
        bool Loop;
        float TesselationFactor;
        float Radius;
    };
    StructuredBuffer<SplineSettings> SplineSettingsBuffer;

    stream float4 Dir : NORMAL;

    // VS ==============================================================================

    stage void VSMain() 
    {
        streams.iv = streams.VertexID;
    }


    //// HS CONSTANT ===================================================================

    patchstream float tessFactor[2] : SV_TessFactor;

    stage void HSConstantMain(InputPatch<Input, 1> input, const OutputPatch<Input2, 1> output, out Constants constants) 
    {
        SplineSettings s = SplineSettingsBuffer[0];

        constants.tessFactor[0] = 1.0f;
        constants.tessFactor[1] = s.TesselationFactor;
    }


    //// HS ==============================================================================

    [domain("isoline")]
    [partitioning("fractional_even")]
    [outputtopology("line")]
    [outputcontrolpoints(1)]
    [patchconstantfunc("HSConstantMain")]
    stage void HSMain(InputPatch<Input, 1> input, out Output output, uint uCPID : SV_OutputControlPointID) 
    {
        streams = input[uCPID];
        output = streams;
    }

    //// DS ==============================================================================

    //SPLINE DISTORT FUNCTION
    //float3 dist(float3 pos,int splineid=0,float t=0)
    //{
    //    float3 p=pos;
    //    p=mul(float4(p.xyz,1),sbLoad(sbTransform, dMat,splineid)).xyz;
    //    return p;
    //}

    //interface iSplineWidth
    //{
    //   float Get(float splineID, int offset, int startctrl, int endctrl, float range);
    //};
    //class cPerSpline : iSplineWidth    // width is per spline 
    //{
    //    float Get(float splineID, int offset, int startctrl, int endctrl, float range)
	   // {
		  //  return sbLoad(sbRadius,Radius,splineID);
	   // }
    //}; 

    //class cPerSegment : iSplineWidth    // sample width over contorl points
    //{
    //   float Get(float splineID, int offset, int startctrl, int endctrl, float range)
	   // {
		  //  if(Loop)
		  //  {
			 //   float c1 = sbLoad(sbRadius,Radius,(range-1)%(uint)ControlPointPerSpline+offset);
			 //   float c2 = sbLoad(sbRadius,Radius,(range-0)%(uint)ControlPointPerSpline+offset);
			 //   float c3 = sbLoad(sbRadius,Radius,(range+1)%(uint)ControlPointPerSpline+offset);
			 //   float c4 = sbLoad(sbRadius,Radius,(range+2)%(uint)ControlPointPerSpline+offset);
			 //   return BSplineCubic(c1,c2,c3,c4,range);
		  //  }
		  //  else
		  //  {
			 //   float c1 = sbLoad(sbRadius,Radius, clamp(range-1,startctrl,endctrl)+offset);
			 //   float c2 = sbLoad(sbRadius,Radius, clamp(range-0,startctrl,endctrl)+offset);
			 //   float c3 = sbLoad(sbRadius,Radius, clamp(range+1,startctrl,endctrl)+offset);
			 //   float c4 = sbLoad(sbRadius,Radius, clamp(range+2,startctrl,endctrl)+offset);
			 //   return BSplineCubic(c1,c2,c3,c4,range);
		  //  }
		

	   // }
    //}; 

    stream float4 TexCoord : TEXCOORD0;
    stream uint iv : VERTEXID;
    stream uint si;

    [domain("isoline")]
    stage void DSMain(const OutputPatch<Input, 1> input, out Output output, in Constants constants, float2 uv : SV_DomainLocation) 
    {    
        SplineSettings s = SplineSettingsBuffer[0];

	    //Retrieve spline id and vertex id
	    int splineid = input[0].iv / s.VertexPerSpline;	
	    int segmentid = input[0].iv % s.VertexPerSpline;
	
	    //That's the control point range in the buffer
	    int offset = splineid * s.ControlPointPerSpline;
	    //int startctrl = splineid * ControlPointPerSpline;
	    //int endctrl = startctrl + ControlPointPerSpline -1;
	    int startctrl = 0;
	    int endctrl = s.ControlPointPerSpline -1;
	
	    //number between 0 and 1 generated by tesselator
	    float t = uv.x;
	 
	    //Rebuild with segment ids
	    float segmentsize = 1.0f / (float)s.VertexPerSpline;
	    t *= segmentsize;
	    t += segmentsize * (float)segmentid;

	
	    SplinePosTan3 sp=(SplinePosTan3)0;

	    //That will be nearest control point
	    //int t2 = floor(t*ControlPointPerSpline) + startctrl;
	    int cpBufferSize = sbSize3(ControlPointBuffer);
	    int t2 = (t * s.ControlPointPerSpline);
	    //Grab four control points around our coordinate
	    float3 c1 = ControlPointBuffer[clamp(t2-1,startctrl,endctrl) + offset % cpBufferSize];
	    float3 c2 = ControlPointBuffer[clamp(t2-0,startctrl,endctrl) + offset % cpBufferSize];
	    float3 c3 = ControlPointBuffer[clamp(t2+1,startctrl,endctrl) + offset % cpBufferSize];
	    float3 c4 = ControlPointBuffer[clamp(t2+2,startctrl,endctrl) + offset % cpBufferSize];
	    //Compute spline equation (which has derivative for normal and other bits)
	    sp = BSplineCubic3PT(c1, c2, c3, c4, t * s.ControlPointPerSpline);
	
	
	    if(s.Loop){
	    t2 += s.ControlPointPerSpline;
	    float3 c1 = ControlPointBuffer[(t2-1)%(uint)s.ControlPointPerSpline + offset % cpBufferSize];
	    float3 c2 = ControlPointBuffer[(t2-0)%(uint)s.ControlPointPerSpline + offset % cpBufferSize];
	    float3 c3 = ControlPointBuffer[(t2+1)%(uint)s.ControlPointPerSpline + offset % cpBufferSize];
	    float3 c4 = ControlPointBuffer[(t2+2)%(uint)s.ControlPointPerSpline + offset % cpBufferSize];
	    sp = BSplineCubic3PT(c1, c2, c3, c4, t * s.ControlPointPerSpline);
	    }
	
	    float3 p=sp.Pos.xyz;
	
	    //sp.Pos.xyz = dist(sp.Pos.xyz,splineid,t);
	    //sp.Tang.xyz = dist(p+normalize(sp.Tang)*TangentEpsilon,splineid,t)-sp.Pos.xyz;

	    float width = sbLoad(RadiusBuffer, s.Radius, splineid);//widthIndexing.Get(splineid, offset,  startctrl,  endctrl,  t*ControlPointPerSpline);
        streams.PositionWS = float4(sp.Pos.xyz, width);
	    streams.Dir = float4(normalize(sp.Tang), 0);
	    streams.TexCoord = float4(t,0,0,0);
	    if(!s.Loop)
        streams.TexCoord.y = t > segmentsize * (s.VertexPerSpline) * (1-0.25/(s.VertexPerSpline * s.TesselationFactor));
        streams.si = splineid;
        
        //streams.ShadingPosition = mul(float4(streams.PositionWS.xyz, 1), ViewProjection);
        output = streams;


	    ///*Here we only need the x component (from 0 to 1) 
	    //of the DomainLocation (which we can use to compute bezier)*/
     //   float t = uv.x;
	
	    ////Compute bezier from quadratic formula
	    //float3 pos = pow(1.0f - t, 2.0f) * input[0].PosW.xyz 
	    //+ 2.0f * (1.0f - t) * t * input[1].PosW.xyz
	    //+ (t*t) * input[2].PosW.xyz ;

	    ////Project in screen space (if we have a camera
     //   streams.PosWVP = mul(float4(pos, 1.0f), ViewProjection);

     //   output = streams;
    }

    // GS ==============================================================================
    #define TUBE_RES 8
    #define MAXVCOUNT (TUBE_RES+1)*2

    static const float3 UpVector = float3(0, 1, 0);
    float3x3 lookat(float3 dir,float3 up=float3(0,1,0)){float3 z=normalize(dir);float3 x=normalize(cross(up,z));float3 y=normalize(cross(z,x));return float3x3(x,y,z);} 
    
    void GS_TubePoint(float3x3 m, Input In, int i,float2 TexCd, inout TriangleStream<Output> GSOut)
    {
	    streams = In;
	    //float4x4 tRing=sbRing[In.si%RingTransformCount];
	    //float4x4 tRingIT=sbRingIT[In.si%RingTransformCount];
	    float fRad = In.PositionWS.w;
	    float3 ring=float3(sin(((float)i/TUBE_RES-.5/TUBE_RES+float2(-.25,0))*acos(-1)*2).xy,0);
	
	    //float3 pos = (mul(mul(float4(ring * fRad,1),tRing).xyz,m ));
	    //float3 norm = normalize(mul(mul(float4(ring,1),tRingIT).xyz,m ));
	    float3 pos = mul(ring * fRad, m);
	    float3 norm = normalize(mul(ring,m));
	
	    //norm = mul(float4(norm,0),tWIT).xyz;
	    pos += In.PositionWS.xyz;
	    //Out.PosWVP = mul( float4(pos,1), tWVP );
	    streams.ShadingPosition = float4(pos, 1);
	    streams.Dir = float4(norm, 0);
	    //Out.TexCd.xy=mul(float4((TexCd.xy*2-1)*float2(1,-1),0,1), sbLoad(sbTexTransform, dTMat, In.si)).xy*float2(1,-1)*.5+.5;
	    streams.TexCoord.xy = (TexCd.xy*2-1) * float2(1, -1) * float2(1, -1) * .5 + .5;
	    //streams.iid = In.si;

	    GSOut.Append(streams);
    }

    //max v count
    [StreamOutput("SV_Position.xyzw;NORMAL.xyzw;TEXCOORD0.xyzw")]
    [maxvertexcount(18)]
    stage void GSMain(line Input In[2], inout TriangleStream<Output> GSOut)
    {
	    if(In[1].TexCoord.y==1)return;
	    float3 up = UpVector;
	    //up=mul(float3(0,0,1),(float3x3)tVI);

	    float3x3 m0=lookat(In[0].Dir,up);
	    float3x3 m1=lookat(In[1].Dir,up);

	    for(int i=0; i < TUBE_RES + 1; i++)
        {
		    GS_TubePoint( m1, In[1], i,float2(In[1].TexCoord.x,(float)i/TUBE_RES), GSOut );
		    GS_TubePoint( m0, In[0], i,float2(In[0].TexCoord.x,(float)i/TUBE_RES), GSOut );
	    }
	    GSOut.RestartStrip();
    }


    // PS ==============================================================================

    //stage void PSMain()
    //{
    //    streams.ColorTarget = float4(streams.Dir.xyz*0.5+0.5,1);
    //}
};

